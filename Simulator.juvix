module Simulator;

open import Simulator.Resource public;
open import Simulator.Balance public;
open import Simulator.PartialTx public;

open import Stdlib.Prelude;
open import Stdlib.Debug.Fail;
open import Data.ByteString public;

import Data.Map as Map;
open Map using {Map};

import Stdlib.Data.Int as Int;

--- Arguments: hash of itself, consumed (input/spend/send/destroyed), created (output/received)
LogicFunction : Type;
LogicFunction := LogicHash -> List Resource -> List Resource -> Bool;

alwaysValid : LogicFunction;
alwaysValid :=
  λ {
    | _ _ _ := true
  };

validPartialTx :
  Map LogicHash LogicFunction -> PartialTx -> Bool;
validPartialTx m (partialTx inr outr) :=
  let
    resources : List Resource;
    resources := inr ++ outr;
    getLogicFn : Resource -> (List Resource -> List Resource -> Bool);
    getLogicFn (resource logicHash _ _ _) :=
      case Map.lookup NatTraits.Ord logicHash m
      | just f := f logicHash
      | _ := (fail
          ("Could not find function associated with hash: "
            ++str natToString logicHash));
  in all
    λ {
      | r := getLogicFn r inr outr
    }
    resources;

denomination : Resource -> ByteString;
denomination (resource logicHash staticData _ _) :=
  logicHash :: staticData;

--- Aggregate the quantities associated with a denomination
quantityOfDenom : ByteString -> List Resource -> Int;
quantityOfDenom denom rs :=
  let
    resourcesForDenom : List Resource;
    resourcesForDenom :=
      filter
        λ {
          | r :=
            case ListTraits.Eq NatTraits.Eq
              | mkEq eqList := eqList (denomination r) denom
        }
        rs;
  in foldl
    (Int.+)
    (Int.ofNat 0)
    (map quantity resourcesForDenom);

mkBalance : Resource -> Balance;
mkBalance r@(resource _ _ _ quantity) :=
  balance ((denomination r, quantity) :: nil);

balanceDelta : PartialTx -> Balance;
balanceDelta (partialTx inr outr) :=
  subBalance
    (sumBalances (map mkBalance inr))
    (sumBalances (map mkBalance outr));

checkTransaction :
  Map LogicHash LogicFunction -> List PartialTx -> Bool;
checkTransaction m ptxs :=
  let
    allValid : Bool := all (validPartialTx m) ptxs;
    sumDeltasIsZero :
        Bool :=
          balanceIsZero (sumBalances (map balanceDelta ptxs));
  in allValid && sumDeltasIsZero;
