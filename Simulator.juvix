module Simulator;

open import Simulator.Resource public;
open import Simulator.Balance public;
open import Simulator.PartialTx public;

open import Stdlib.Prelude;
open import Stdlib.Debug.Fail;
open import Data.ByteString public;

import Data.Set as Set;
open Set using {Set};

import Data.Map as Map;
open Map using {Map};

--- Arguments: hash of itself, consumed (input/spend/send/destroyed), created (output/received)
LogicFunction : Type;
LogicFunction := LogicHash -> Set Resource -> Set Resource -> Bool;

validPartialTx :
  Map LogicHash LogicFunction -> PartialTx -> Bool;
validPartialTx m (partialTx inr outr) :=
  let
    resources : List Resource;
    resources := Set.toList inr ++ Set.toList outr;
    getLogicFn : Resource -> (Set Resource -> Set Resource -> Bool);
    getLogicFn (resource logicHash _ _ _) :=
      case Map.lookup NatTraits.Ord logicHash m
      | just f := f logicHash
      | _ := (fail
          ("Could not find function associated with hash: "
            ++str natToString logicHash));
  in all
    Î» {
      | r := getLogicFn r inr outr
    }
    resources;

denomination : Resource -> ByteString;
denomination (resource logicHash staticData _ _) :=
  logicHash :: staticData;

mkBalance : Resource -> Balance;
mkBalance r@(resource _ _ _ quantity) :=
  balance ((denomination r, quantity) :: nil);

balanceDelta : PartialTx -> Balance;
balanceDelta (partialTx inr outr) :=
  subBalance
    (sumBalances (map mkBalance (Set.toList inr)))
    (sumBalances (map mkBalance (Set.toList outr)));

checkTransaction :
  Map LogicHash LogicFunction -> Set PartialTx -> Bool;
checkTransaction m ptxs :=
  let
    ptxsList : List PartialTx := Set.toList ptxs;
    allValid : Bool := all (validPartialTx m) ptxsList;
    sumDeltasIsZero :
        Bool :=
          balanceIsZero (sumBalances (map balanceDelta ptxsList));
  in allValid && sumDeltasIsZero;
