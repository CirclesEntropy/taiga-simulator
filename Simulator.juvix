module Simulator;

open import Simulator.Resource public;
open import Simulator.Balance public;
open import Simulator.PartialTx public;
open import Simulator.Denomination public;

open import Stdlib.Prelude;
open import Stdlib.Debug.Fail;
open import Data.ByteString public;

import Data.Map as Map;
open Map using {Map};

--- Arguments: kind (indicating whether the resource associated with the logic
--- function was consumed or created in the partial transaction), consumed resources
--- (input/spend/send/destroyed), created resources (output/received)
LogicFunction : Type;
LogicFunction := ResourceKind -> PartialTx -> Bool;

alwaysValid : LogicFunction;
alwaysValid :=
  λ {
    | _ _ := true
  };

validPartialTx :
  Map LogicHash LogicFunction -> PartialTx -> Bool;
validPartialTx m tx :=
  let
    getLogicFn :
        ResourceKind -> Resource -> PartialTx -> Bool;
    getLogicFn kind (resource denom _ _) :=
      let
        hash : LogicHash := logicHash denom;
      in case Map.lookup NatTraits.Ord hash m
        | just f := f kind
        | _ :=
          fail
            ("Could not find function associated with hash: "
              ++str natToString hash);
  in all
      λ {
        | r := getLogicFn created r tx
      }
      (createdResources tx)
    && all
      λ {
        | r := getLogicFn consumed r tx
      }
      (consumedResources tx);

mkBalance : Resource -> Balance;
mkBalance r :=
  balance ((denomination' r, quantity r) :: nil);

balanceDelta : PartialTx -> Balance;
balanceDelta (partialTx inr outr) :=
  subBalance
    (sumBalances (map mkBalance inr))
    (sumBalances (map mkBalance outr));

checkTransaction :
  Map LogicHash LogicFunction -> List PartialTx -> Bool;
checkTransaction m ptxs :=
  let
    allValid : Bool := all (validPartialTx m) ptxs;
    sumDeltasIsZero :
        Bool :=
          balanceIsZero (sumBalances (map balanceDelta ptxs));
  in allValid && sumDeltasIsZero;
