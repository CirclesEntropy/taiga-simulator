module Simulator;

open import Simulator.Resource public;
open import Simulator.Balance public;
open import Simulator.PartialTx public;
open import Simulator.Denomination public;

open import Stdlib.Prelude;
open import Stdlib.Debug.Fail;
open import Data.ByteString public;

import Data.Map as Map;
open Map using {Map};

--- Arguments: hash of itself, consumed (input/spend/send/destroyed), created (output/received)
LogicFunction : Type;
LogicFunction :=
  LogicHash -> List Resource -> List Resource -> Bool;

alwaysValid : LogicFunction;
alwaysValid :=
  λ {
    | _ _ _ := true
  };

validPartialTx :
  Map LogicHash LogicFunction -> PartialTx -> Bool;
validPartialTx m (partialTx inr outr) :=
  let
    resources : List Resource;
    resources := inr ++ outr;
    getLogicFn :
        Resource -> List Resource -> List Resource -> Bool;
    getLogicFn (resource denom _ _) :=
      let
        hash : LogicHash := logicHash denom;
      in case Map.lookup NatTraits.Ord hash m
        | just f := f hash
        | _ :=
          fail
            ("Could not find function associated with hash: "
              ++str natToString hash);
  in all
    λ {
      | r := getLogicFn r inr outr
    }
    resources;

mkBalance : Resource -> Balance;
mkBalance r :=
  balance ((denomination' r, quantity r) :: nil);

balanceDelta : PartialTx -> Balance;
balanceDelta (partialTx inr outr) :=
  subBalance
    (sumBalances (map mkBalance inr))
    (sumBalances (map mkBalance outr));

checkTransaction :
  Map LogicHash LogicFunction -> List PartialTx -> Bool;
checkTransaction m ptxs :=
  let
    allValid : Bool := all (validPartialTx m) ptxs;
    sumDeltasIsZero :
        Bool :=
          balanceIsZero (sumBalances (map balanceDelta ptxs));
  in allValid && sumDeltasIsZero;
