module Simulator.Resource;

open import Stdlib.Prelude;
open import Data.ByteString;
open import Simulator.Denomination;

import Stdlib.Data.Int as Int;

type Resource :=
  | resource : Denomination
      -> ByteString
      -> Int
      -> Resource;

dynamicData : Resource -> ByteString;
dynamicData (resource _ d _) := d;

quantity : Resource -> Int;
quantity (resource _ _ q) := q;

denomination' : Resource -> Denomination;
denomination' (resource d _ _) := d;

--- Aggregate the quantities associated with a denomination
quantityOfDenom : Denomination -> List Resource -> Int;
quantityOfDenom denom rs :=
  let
    resourcesForDenom : List Resource;
    resourcesForDenom :=
      filter
        λ {
          | r := eq DenominationTraits.Eq (denomination' r) denom
        }
        rs;
  in foldl
    (Int.+)
    (Int.ofNat 0)
    (map quantity resourcesForDenom);

module ResourceTraits;

  import Stdlib.Trait.Ord as Stdlib;

  Ord : Stdlib.Ord Resource;
  Ord :=
    let
      prod : Resource -> Denomination × ByteString × Int;
      prod (resource denom d q) := denom, d, q;
      prodOrd : Stdlib.Ord (Denomination × ByteString × Int);
      prodOrd :=
        ProductTraits.Ord
          DenominationTraits.Ord
          (ProductTraits.Ord ByteStringTraits.Ord IntTraits.Ord);
      go :
          Stdlib.Ord (Denomination × ByteString × Int)
            -> Resource
            -> Resource
            -> Ordering;
      go (mkOrd prod-ord) r1 r2 := prod-ord (prod r1) (prod r2);
    in mkOrd (go prodOrd);

end;

type ResourceKind :=
  | created : ResourceKind
  | consumed : ResourceKind;

module ResourceKindTraits;

  Eq : Eq ResourceKind;
  Eq :=
    mkEq
      λ {
        | created created := true
        | consumed consumed := true
        | _ _ := false
      };

end;
