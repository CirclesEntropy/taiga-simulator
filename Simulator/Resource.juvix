module Simulator.Resource;

open import Stdlib.Prelude;
open import Data.ByteString;
open import Simulator.Denomination;

import Stdlib.Data.Int as Int;

type Resource :=
  | resource : Denomination
      -> ByteString
      -> Int
      -> Resource;

dynamicData : Resource -> ByteString;
dynamicData (resource _ d _) := d;

quantity : Resource -> Int;
quantity (resource _ _ q) := q;

denomination' : Resource -> Denomination;
denomination' (resource d _ _) := d;

--- Aggregate the quantities associated with a denomination
quantityOfDenom : Denomination -> List Resource -> Int;
quantityOfDenom denom rs :=
  let
    resourcesForDenom : List Resource;
    resourcesForDenom :=
      filter
        λ {
          | r :=
            case denominationEq
              | mkEq eqList := eqList (denomination' r) denom
        }
        rs;
  in foldl
    (Int.+)
    (Int.ofNat 0)
    (map quantity resourcesForDenom);

resource-ordering : Ord Resource;
resource-ordering :=
  let
    prod : Resource -> Denomination × ByteString × Int;
    prod (resource denom d q) := denom, d, q;
    prodOrd : Ord (Denomination × ByteString × Int);
    prodOrd :=
      ProductTraits.Ord
        denominationOrd
        (ProductTraits.Ord orderingByteString IntTraits.Ord);
    go :
        Ord (Denomination × ByteString × Int)
          -> Resource
          -> Resource
          -> Ordering;
    go (mkOrd prod-ord) r1 r2 := prod-ord (prod r1) (prod r2);
  in mkOrd (go prodOrd);
