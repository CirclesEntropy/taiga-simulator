module Simulator.Denomination;

open import Stdlib.Prelude;
open import Data.ByteString;

--- The hash of a logic function
LogicHash : Type;
LogicHash := Nat;

--- The type of a Resource
type Denomination :=
  | denomination : LogicHash -> ByteString -> Denomination;

logicHash : Denomination -> LogicHash;
logicHash (denomination h _) := h;

staticData : Denomination -> ByteString;
staticData (denomination _ d) := d;

module DenominationTraits;

  import Stdlib.Trait.Eq as Stdlib;
  import Stdlib.Trait.Ord as Stdlib;

  Eq : Stdlib.Eq Denomination;
  Eq :=
    let
      prod : Denomination -> LogicHash × ByteString;
      prod (denomination h d) := h, d;
      prodEq : Stdlib.Eq (LogicHash × ByteString);
      prodEq := ProductTraits.Eq NatTraits.Eq ByteStringTraits.Eq;
    in mkEq
      λ {
        | d1 d2 := eq prodEq (prod d1) (prod d2)
      };

  Ord : Stdlib.Ord Denomination;
  Ord :=
    let
      prod : Denomination -> LogicHash × ByteString;
      prod (denomination h d) := h, d;
      prodOrd : Stdlib.Ord (LogicHash × ByteString);
      prodOrd :=
        ProductTraits.Ord NatTraits.Ord ByteStringTraits.Ord;
    in mkOrd
      λ {
        | d1 d2 := cmp prodOrd (prod d1) (prod d2)
      };

end;
