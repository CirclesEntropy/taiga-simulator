-- Taiga two party exchange example
-- https://github.com/anoma/taiga/blob/main/book/src/exec_examples.md#1-two-party-exchange-with-an-intent-uservp
module Apps.TwoPartyExchange;

open import Simulator;

import Data.Map as Map;
open Map using {Map};

open import Stdlib.Prelude;

open import Stdlib.Data.Int.Ord;

module AlwaysValid;
  logicFunction : LogicFunction;
  logicFunction := Î» {_ _ := true};

  --- This will be computed from the logic function
  logicHash : LogicHash;
  logicHash := 0;
end;

module Dolphin;
  staticData : ByteString;
  staticData := 0 :: nil;

  mkResource : Int -> Resource;
  mkResource := resource AlwaysValid.logicHash staticData nil;

  denomination : Denomination;
  denomination := AlwaysValid.logicHash :: staticData;
end;

module A;
  staticData : ByteString;
  staticData := 1 :: nil;

  mkResource : Int -> Resource;
  mkResource := resource AlwaysValid.logicHash staticData nil;

  denomination : Denomination;
  denomination := AlwaysValid.logicHash :: staticData;
end;

module B;
  staticData : ByteString;
  staticData := 2 :: nil;

  mkResource : Int -> Resource;
  mkResource := resource AlwaysValid.logicHash staticData nil;

  denomination : Denomination;
  denomination := AlwaysValid.logicHash :: staticData;
end;

module AliceIntent;
  logicFunction : LogicFunction;
  logicFunction kind tx :=
    -- check if the resource associated to this logic function is among the created (output)
    -- resources.
    -- Then check if alice's intent is satisfied.
    let
      createdRs : List Resource;
      createdRs := createdResources tx;
      createdHashes : List LogicHash;
      createdHashes := map logicHash createdRs;
    in isCreated kind
      || quantityOfDenom Dolphin.denomination createdRs == 1
      && quantityOfDenom A.denomination createdRs == 1
      || quantityOfDenom Dolphin.denomination createdRs == 1
      && quantityOfDenom B.denomination createdRs == 2;

  --- This will be computed from the logic function
  logicHash : LogicHash;
  logicHash := 1;

  staticData : ByteString;
  staticData := 3 :: nil;

  denomination : Denomination;
  denomination := 1 :: staticData;

  mkResource : Int -> Resource;
  mkResource := resource logicHash staticData nil;
end;

logicFunctions : Map LogicHash LogicFunction;
logicFunctions :=
  Map.fromList
    NatTraits.Ord
    ((AlwaysValid.logicHash, AlwaysValid.logicFunction)
      :: (AliceIntent.logicHash, AliceIntent.logicFunction)
      :: nil);
