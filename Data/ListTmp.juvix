module Data.ListTmp;

open import Stdlib.Prelude hiding {transpose; splitAt};

open import Stdlib.Data.Nat.Ord;
import Data.Set as Set;
open Set using {Set};

find : {A : Type} -> (A -> Bool) -> List A -> Maybe A;
find _ nil := nothing;
find p (x :: xs) := if (p x) (just x) (find p xs);

headMay : {A : Type} -> List A -> Maybe A;
headMay nil := nothing;
headMay (x :: _) := just x;

ordNub : {A : Type} -> Ord A -> List A -> List A;
ordNub {A} o :=
  let
    go : Set A -> List A -> List A;
    go _ nil := nil;
    go s (x :: xs) :=
      if
        (Set.member? o x s)
        (go s xs)
        (x :: go (Set.insert o x s) xs);
  in go Set.empty;

hasDuplicates : {A : Type} -> Ord A -> List A -> Bool;
hasDuplicates o xs := length (ordNub o xs) /= length xs;

allEq : {A : Type} -> Eq A -> List A -> Bool;
allEq {A} _ nil := true;
allEq {A} eqA (x :: xs) :=
  let
    go : List A -> Bool;
    go nil := true;
    go (y :: ys) := if (eq eqA x y) (go ys) false;
  in go xs;

transpose : {A : Type} -> List (List A) -> List (List A);
transpose nil := nil;
transpose (xs :: nil) := map (λ { x := x :: nil }) xs;
transpose (xs :: xss) := zipWith (::) xs (transpose xss);

--- 𝒪(𝓃). splitAt n xs returns a tuple where first element is xs
--- prefix of length n and second element is the remainder of the ;List;.
splitAt : {A : Type} → Nat → List A → List A × List A;
splitAt _ nil := nil, nil;
splitAt zero xs := nil, xs;
splitAt (suc zero) (x :: xs) := x :: nil, xs;
splitAt (suc (suc m)) (x :: xs) :=
  first ((::) x) (splitAt (suc m) xs);

terminating
chunksOf : {A : Type} -> Nat -> List A -> List (List A);
chunksOf _ nil := nil;
chunksOf n xs := case (splitAt n xs)
  | (ys , zs) := ys :: chunksOf n zs;
